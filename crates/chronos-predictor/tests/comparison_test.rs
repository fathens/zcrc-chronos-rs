//! Comparison tests: Rust implementation vs Python golden data.
//!
//! Golden JSON files are generated by `zcrc-chronos/scripts/generate_golden_data.py`
//! and stored at the workspace root: `tests/golden/`.

use std::collections::HashMap;
use std::path::PathBuf;

use chrono::NaiveDateTime;
use serde::Deserialize;

// ---------------------------------------------------------------------------
// Golden data deserialization types
// ---------------------------------------------------------------------------

#[derive(Deserialize)]
struct NormalizeCase {
    input: NormalizeIO,
    output: NormalizeIO,
}

#[derive(Deserialize)]
struct NormalizeIO {
    timestamps: Vec<String>,
    values: Vec<f64>,
}

#[derive(Deserialize)]
struct AnalyzerCase {
    input: AnalyzerInput,
    output: AnalyzerOutput,
}

#[derive(Deserialize)]
struct AnalyzerInput {
    timestamps: Vec<String>,
    values: Vec<f64>,
}

#[derive(Deserialize)]
struct AnalyzerOutput {
    trend: GoldenTrend,
    seasonality: GoldenSeasonality,
    volatility: f64,
    stationarity: GoldenStationarity,
    frequency: GoldenFrequency,
    density: GoldenDensity,
    outliers: GoldenOutliers,
    missing_pattern: GoldenMissingPattern,
}

#[derive(Deserialize)]
struct GoldenTrend {
    strength: String,
    direction: String,
    slope: f64,
    r_squared: f64,
    #[allow(dead_code)]
    p_value: f64,
    mann_kendall: GoldenMannKendall,
}

#[derive(Deserialize)]
struct GoldenMannKendall {
    #[allow(dead_code)]
    trend: String,
    #[allow(dead_code)]
    p_value: f64,
    #[serde(rename = "S")]
    s_statistic: i64,
}

#[derive(Deserialize)]
struct GoldenSeasonality {
    strength: String,
    period: Option<usize>,
    score: f64,
    #[allow(dead_code)]
    dominant_frequency: Option<f64>,
}

#[derive(Deserialize)]
struct GoldenStationarity {
    is_stationary: serde_json::Value, // Python outputs "True"/"False" as strings
    #[allow(dead_code)]
    mean_difference: f64,
    #[allow(dead_code)]
    variance_ratio: f64,
}

#[derive(Deserialize)]
struct GoldenFrequency {
    estimated: String,
    confidence: f64,
    #[allow(dead_code)]
    median_interval_seconds: f64,
}

#[derive(Deserialize)]
struct GoldenDensity {
    regular: serde_json::Value, // Python outputs "True"/"False" as strings
    #[allow(dead_code)]
    mean_interval: f64,
    coefficient_of_variation: f64,
}

#[derive(Deserialize)]
struct GoldenOutliers {
    count: usize,
    #[allow(dead_code)]
    percentage: f64,
    indices: Vec<usize>,
}

#[derive(Deserialize)]
struct GoldenMissingPattern {
    has_gaps: bool,
    gap_count: usize,
}

#[derive(Deserialize)]
struct SelectorCase {
    input: SelectorInput,
    output: SelectorOutput,
}

#[derive(Deserialize)]
struct SelectorInput {
    timestamps: Vec<String>,
    values: Vec<f64>,
    horizon: usize,
    time_budget: u64,
}

#[derive(Deserialize)]
struct SelectorOutput {
    strategy_name: String,
    priority_models: Vec<String>,
    excluded_models: Vec<String>,
    time_allocation: GoldenTimeAllocation,
    preset: String,
}

#[derive(Deserialize)]
struct GoldenTimeAllocation {
    fast: f64,
    medium: f64,
    advanced: f64,
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

fn golden_dir() -> PathBuf {
    let manifest = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    // crates/chronos-predictor/../../tests/golden/
    manifest.join("../../tests/golden")
}

fn parse_timestamps(ts_strings: &[String]) -> Vec<NaiveDateTime> {
    ts_strings
        .iter()
        .map(|s| NaiveDateTime::parse_from_str(s, "%Y-%m-%dT%H:%M:%S").unwrap())
        .collect()
}

fn load_golden<T: serde::de::DeserializeOwned>(filename: &str) -> HashMap<String, T> {
    let path = golden_dir().join(filename);
    let content = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", path.display(), e));
    serde_json::from_str(&content)
        .unwrap_or_else(|e| panic!("Failed to parse {}: {}", path.display(), e))
}

/// Parse Python bool strings ("True"/"False") from JSON Value.
fn parse_python_bool(val: &serde_json::Value) -> bool {
    match val {
        serde_json::Value::Bool(b) => *b,
        serde_json::Value::String(s) => s == "True",
        _ => false,
    }
}

fn assert_close(actual: f64, expected: f64, tolerance: f64, label: &str) {
    let diff = (actual - expected).abs();
    assert!(
        diff < tolerance,
        "{label}: expected {expected}, got {actual} (diff={diff}, tol={tolerance})"
    );
}

fn assert_relative_close(actual: f64, expected: f64, rel_tol: f64, label: &str) {
    if expected.abs() < 1e-12 {
        assert_close(actual, expected, rel_tol, label);
        return;
    }
    let rel_diff = ((actual - expected) / expected).abs();
    assert!(
        rel_diff < rel_tol,
        "{label}: expected {expected}, got {actual} (rel_diff={rel_diff:.6}, rel_tol={rel_tol})"
    );
}

// ---------------------------------------------------------------------------
// Normalize comparison tests
// ---------------------------------------------------------------------------

#[test]
fn test_normalize_matches_python() {
    let cases: HashMap<String, NormalizeCase> = load_golden("normalize_output.json");

    for (name, case) in &cases {
        let input_ts = parse_timestamps(&case.input.timestamps);
        let input_vals = &case.input.values;

        let (out_ts, out_vals) =
            chronos_normalize::normalize_time_series_data(&input_ts, input_vals).unwrap();

        let expected_ts = parse_timestamps(&case.output.timestamps);

        // Timestamp count must match
        assert_eq!(
            out_ts.len(),
            expected_ts.len(),
            "[{name}] timestamp count mismatch"
        );

        // Timestamps must match exactly
        for (i, (actual, expected)) in out_ts.iter().zip(expected_ts.iter()).enumerate() {
            assert_eq!(
                actual, expected,
                "[{name}] timestamp mismatch at index {i}"
            );
        }

        // Values must match within floating-point tolerance
        assert_eq!(
            out_vals.len(),
            case.output.values.len(),
            "[{name}] value count mismatch"
        );
        for (i, (actual, expected)) in
            out_vals.iter().zip(case.output.values.iter()).enumerate()
        {
            assert_close(
                *actual,
                *expected,
                1e-10,
                &format!("[{name}] value at index {i}"),
            );
        }
    }
}

// ---------------------------------------------------------------------------
// Analyzer comparison tests
// ---------------------------------------------------------------------------

#[test]
fn test_analyzer_trend_matches_python() {
    let cases: HashMap<String, AnalyzerCase> = load_golden("analyzer_output.json");
    let analyzer = chronos_analyzer::TimeSeriesAnalyzer::new();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = analyzer.analyze(values, &timestamps);
        let expected = &case.output.trend;

        // Trend strength and direction must match exactly
        assert_eq!(
            result.trend.strength, expected.strength,
            "[{name}] trend strength mismatch"
        );
        assert_eq!(
            result.trend.direction, expected.direction,
            "[{name}] trend direction mismatch"
        );

        // Slope and r_squared within tolerance
        assert_close(
            result.trend.slope,
            expected.slope,
            1e-4,
            &format!("[{name}] trend slope"),
        );
        assert_close(
            result.trend.r_squared,
            expected.r_squared,
            1e-4,
            &format!("[{name}] trend r_squared"),
        );

        // Mann-Kendall S statistic must match exactly
        assert_eq!(
            result.trend.mann_kendall.s_statistic,
            expected.mann_kendall.s_statistic,
            "[{name}] Mann-Kendall S mismatch"
        );
    }
}

#[test]
fn test_analyzer_seasonality_matches_python() {
    let cases: HashMap<String, AnalyzerCase> = load_golden("analyzer_output.json");
    let analyzer = chronos_analyzer::TimeSeriesAnalyzer::new();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = analyzer.analyze(values, &timestamps);
        let expected = &case.output.seasonality;

        // Strength classification must match
        assert_eq!(
            result.seasonality.strength, expected.strength,
            "[{name}] seasonality strength mismatch"
        );

        // Period must match (None vs Some)
        assert_eq!(
            result.seasonality.period, expected.period,
            "[{name}] seasonality period mismatch"
        );

        // Score within tolerance
        assert_close(
            result.seasonality.score,
            expected.score,
            1e-3,
            &format!("[{name}] seasonality score"),
        );
    }
}

#[test]
fn test_analyzer_volatility_matches_python() {
    let cases: HashMap<String, AnalyzerCase> = load_golden("analyzer_output.json");
    let analyzer = chronos_analyzer::TimeSeriesAnalyzer::new();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = analyzer.analyze(values, &timestamps);
        let expected_vol = case.output.volatility;

        assert_relative_close(
            result.volatility,
            expected_vol,
            0.01, // 1% relative tolerance
            &format!("[{name}] volatility"),
        );
    }
}

#[test]
fn test_analyzer_stationarity_matches_python() {
    let cases: HashMap<String, AnalyzerCase> = load_golden("analyzer_output.json");
    let analyzer = chronos_analyzer::TimeSeriesAnalyzer::new();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = analyzer.analyze(values, &timestamps);
        let expected_stationary = parse_python_bool(&case.output.stationarity.is_stationary);

        assert_eq!(
            result.stationarity.is_stationary,
            Some(expected_stationary),
            "[{name}] stationarity mismatch"
        );
    }
}

#[test]
fn test_analyzer_frequency_matches_python() {
    let cases: HashMap<String, AnalyzerCase> = load_golden("analyzer_output.json");
    let analyzer = chronos_analyzer::TimeSeriesAnalyzer::new();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = analyzer.analyze(values, &timestamps);
        let expected = &case.output.frequency;

        assert_eq!(
            result.frequency.estimated, expected.estimated,
            "[{name}] frequency estimated mismatch"
        );
        assert_close(
            result.frequency.confidence,
            expected.confidence,
            1e-6,
            &format!("[{name}] frequency confidence"),
        );
    }
}

#[test]
fn test_analyzer_density_matches_python() {
    let cases: HashMap<String, AnalyzerCase> = load_golden("analyzer_output.json");
    let analyzer = chronos_analyzer::TimeSeriesAnalyzer::new();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = analyzer.analyze(values, &timestamps);
        let expected = &case.output.density;

        let expected_regular = parse_python_bool(&expected.regular);
        assert_eq!(
            result.density.regular, expected_regular,
            "[{name}] density regular mismatch"
        );
        assert_close(
            result.density.coefficient_of_variation,
            expected.coefficient_of_variation,
            1e-6,
            &format!("[{name}] density CV"),
        );
    }
}

#[test]
fn test_analyzer_outliers_matches_python() {
    let cases: HashMap<String, AnalyzerCase> = load_golden("analyzer_output.json");
    let analyzer = chronos_analyzer::TimeSeriesAnalyzer::new();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = analyzer.analyze(values, &timestamps);
        let expected = &case.output.outliers;

        assert_eq!(
            result.outliers.count, expected.count,
            "[{name}] outlier count mismatch"
        );
        assert_eq!(
            result.outliers.indices, expected.indices,
            "[{name}] outlier indices mismatch"
        );
    }
}

#[test]
fn test_analyzer_missing_pattern_matches_python() {
    let cases: HashMap<String, AnalyzerCase> = load_golden("analyzer_output.json");
    let analyzer = chronos_analyzer::TimeSeriesAnalyzer::new();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = analyzer.analyze(values, &timestamps);
        let expected = &case.output.missing_pattern;

        assert_eq!(
            result.missing_pattern.has_gaps, expected.has_gaps,
            "[{name}] missing has_gaps mismatch"
        );
        assert_eq!(
            result.missing_pattern.gap_count, expected.gap_count,
            "[{name}] missing gap_count mismatch"
        );
    }
}

// ---------------------------------------------------------------------------
// Selector comparison tests
// ---------------------------------------------------------------------------

#[test]
fn test_selector_strategy_matches_python() {
    let cases: HashMap<String, SelectorCase> = load_golden("selector_output.json");
    let selector = chronos_selector::AdaptiveModelSelector::default();

    for (name, case) in &cases {
        let timestamps = parse_timestamps(&case.input.timestamps);
        let values = &case.input.values;

        let result = selector.select_optimal_strategy(
            values,
            &timestamps,
            case.input.horizon,
            case.input.time_budget,
        );

        let expected = &case.output;

        assert_eq!(
            result.strategy_name, expected.strategy_name,
            "[{name}] strategy_name mismatch"
        );
        // Rust may include additional models (e.g. MSTL) not present in the
        // Python golden data. Check that all Python-expected models are present.
        for model in &expected.priority_models {
            assert!(
                result.priority_models.contains(model),
                "[{name}] priority_models missing '{model}': got {:?}",
                result.priority_models
            );
        }
        assert_eq!(
            result.excluded_models, expected.excluded_models,
            "[{name}] excluded_models mismatch"
        );
        assert_close(
            result.time_allocation.fast,
            expected.time_allocation.fast,
            1e-10,
            &format!("[{name}] time_allocation.fast"),
        );
        assert_close(
            result.time_allocation.medium,
            expected.time_allocation.medium,
            1e-10,
            &format!("[{name}] time_allocation.medium"),
        );
        assert_close(
            result.time_allocation.advanced,
            expected.time_allocation.advanced,
            1e-10,
            &format!("[{name}] time_allocation.advanced"),
        );
        assert_eq!(
            result.preset, expected.preset,
            "[{name}] preset mismatch"
        );
    }
}
